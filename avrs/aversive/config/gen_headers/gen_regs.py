#!/usr/bin/python

import xml.parsers.expat
import sys, re

not_a_register=["IO_START_ADDR",
                "IO_STOP_ADDR",
                "EXT_IO_START_ADDR",
                "EXT_IO_STOP_ADDR",
                "MEM_START_ADDR",
                "MEM_STOP_ADDR",
                ]
curtree=[]

timer_dict={}
sigtimer_OV_dict={}
sigtimer_OC_dict={}
sigtimer_IC_dict={}

bits={}
regs={}


def start_element(name, attrs):
    global state, curtree, sigtimer_list, not_a_register, bits, regs

    curtree.append(name)
    
    if name.find("_MASK") != -1 and len(curtree) > 3 and curtree[-3]=="IO_MEMORY":
        bitname=name.replace("_MASK", "_REG")
        bitname=bitname.replace("-", "_")

        if bits.has_key(bitname)==False:
            bits[bitname]=[]
        bits[bitname].append(curtree[-2])

        if regs.has_key(curtree[-2])==False:
            regs[curtree[-2]]=[]
        regs[curtree[-2]].append(bitname)

def display_timer_infos():
    l=timer_dict.keys()
    l.sort()
    print "/* available timers */"
    for k in l:
        print "#define TIMER%s_AVAILABLE"%k
    print

    l=sigtimer_OV_dict.keys()
    l.sort()
    i=0
    print "/* overflow interrupt number */"
    for k in l:
        print "#define SIG_OVERFLOW%s_NUM %d"%(k,i)
        i+=1
    print "#define SIG_OVERFLOW_TOTAL_NUM %d"%i
    print
    
    l=sigtimer_OC_dict.keys()
    l.sort()
    i=0
    print "/* output compare interrupt number */"
    for k in l:
        print "#define SIG_OUTPUT_COMPARE%s_NUM %d"%(k,i)
        i+=1
    print "#define SIG_OUTPUT_COMPARE_TOTAL_NUM %d"%i
    print
    
    i=0
    print "/* Pwm nums */"
    for k in l:
        print "#define PWM%s_NUM %d"%(k,i)
        i+=1
    print "#define PWM_TOTAL_NUM %d"%i
    print
    
    l=sigtimer_IC_dict.keys()
    l.sort()
    i=0
    print "/* input capture interrupt number */"
    for k in l:
        print "#define SIG_INPUT_CAPTURE%s_NUM %d"%(k,i)
        i+=1
    print "#define SIG_INPUT_CAPTURE_TOTAL_NUM %d"%i
    print
    
        
def end_element(name):
    global state, curtree, sigtimer_list, not_a_register

    if name == "INTERRUPT_VECTOR":
        display_timer_infos()

    curtree.pop()


def char_data(data):
    global state, curtree, sigtimer_list, not_a_register
    global timer_dict, sigtimer_OV_dict, sigtimer_OC_dict, sigtimer_IC_dict

    if len(curtree) > 3 and curtree[-1] == "SOURCE" and re.match("VECTOR[0-9]+",curtree[-2])!=None:
        if (re.match("TIMER[0-9]", data)):

            timernum=re.sub("TIMER([0-9]).*", r"\1", data)
            subtimernum=re.sub("TIMER[0-9].*COMP([A-C])", r"\1", data)
            if len(subtimernum) != 1:
                subtimernum=""
            timerid=timernum+subtimernum
                
            if data.find("OVF")!=-1:
               timer_dict[timerid] = 1
               sigtimer_OV_dict[timerid] = 1
            elif data.find("COMP")!=-1:
               timer_dict[timerid] = 1
               sigtimer_OC_dict[timerid] = 1
            elif data.find("CAPT")!=-1:
               timer_dict[timerid] = 1
               sigtimer_IC_dict[timerid] = 1



print """/*  
 *  Copyright Droids Corporation, Microb Technology, Eirbot (2006)
 * 
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 *  Revision : $Id $
 *
 */

/* WARNING : this file is automatically generated by scripts.
 * You should not edit it. If you find something wrong in it,
 * write to zer0@droids-corp.org */

"""

p = xml.parsers.expat.ParserCreate()

p.StartElementHandler = start_element
p.EndElementHandler = end_element
p.CharacterDataHandler = char_data

f=open(sys.argv[2])
print f.read()
f.close

f=open(sys.argv[1])
p.Parse(f.read(), 1)

for r in regs.keys():
    print 
    print "/* %s */"%r
    for b in regs[r]:
        if len(bits[b]) != 1:
            reglist = bits[b][:]
            reglist.remove(r)
            regliststr = reduce(lambda x, y: x+", "+y, reglist)
            print "/* #define %s %s%s */ /* dup in %s */"%(b, " "*(20-len(b)), r, regliststr)
        else:
            print "#define %s %s%s"%(b, " "*(20-len(b)), r)

f.close()
